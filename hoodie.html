<!DOCTYPE html>
<html lang="fa">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>هودی مردانه | ویرایشگر سه‌بعدی</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    body { margin: 0; overflow: hidden; font-family: 'Vazirmatn', sans-serif; }
    canvas { display: block; }
    #ui-container { position: absolute; top: 20px; left: 20px; z-index: 10; background: rgba(255, 255, 255, 0.7); padding: 10px; border-radius: 8px; }
    .label { font-weight: bold; }
    input, button { margin: 5px 0; padding: 5px; font-size: 14px; }
    .slider { width: 100%; }
  </style>
</head>
<body>
  <div id="ui-container">
    <div class="label">متن جدید:</div>
    <input type="text" id="inputText" placeholder="متن خود را وارد کنید" />
    <div class="label">رنگ:</div>
    <input type="color" id="colorPicker" value="#000000" />
    <div class="label">اندازه:</div>
    <input type="range" id="sizeSlider" class="slider" min="10" max="100" value="50" />
    <button onclick="addText()">اضافه کردن متن</button>
  </div>

  <script>
    let scene, camera, renderer, model, raycaster, mouse, intersectedObject;
    let texts = [];
    let dragging = false;
    let dragObject = null;
    let lastMousePosition = { x: 0, y: 0 };

    init();
    animate();

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Light
      const light = new THREE.AmbientLight(0xffffff, 1);
      scene.add(light);

      // Raycaster
      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();

      // Load model
      const loader = new THREE.GLTFLoader();
      loader.load('https://github.com/Toska-clothes/My_Toska/raw/refs/heads/main/hoodie.glb', (gltf) => {
        model = gltf.scene;
        scene.add(model);
        model.scale.set(0.5, 0.5, 0.5); // Adjust model scale
        camera.position.z = 3;
      });

      window.addEventListener('resize', onWindowResize, false);
      window.addEventListener('mousedown', onMouseDown, false);
      window.addEventListener('mousemove', onMouseMove, false);
      window.addEventListener('mouseup', onMouseUp, false);
      window.addEventListener('touchstart', onTouchStart, false);
      window.addEventListener('touchmove', onTouchMove, false);
      window.addEventListener('touchend', onTouchEnd, false);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onMouseDown(event) {
      event.preventDefault();
      const mouseX = (event.clientX / window.innerWidth) * 2 - 1;
      const mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
      mouse.set(mouseX, mouseY);
      raycaster.update();
      const intersects = getIntersects(mouse.x, mouse.y);
      if (intersects.length > 0) {
        const object = intersects[0].object;
        if (object.text) {
          dragging = true;
          dragObject = object;
          lastMousePosition.x = event.clientX;
          lastMousePosition.y = event.clientY;
        }
      }
    }

    function onMouseMove(event) {
      if (dragging && dragObject) {
        const deltaX = event.clientX - lastMousePosition.x;
        const deltaY = event.clientY - lastMousePosition.y;
        dragObject.position.x += deltaX * 0.01;
        dragObject.position.y -= deltaY * 0.01;
        lastMousePosition.x = event.clientX;
        lastMousePosition.y = event.clientY;
      }
    }

    function onMouseUp() {
      dragging = false;
      dragObject = null;
    }

    function onTouchStart(event) {
      const touch = event.touches[0];
      const mouseX = (touch.clientX / window.innerWidth) * 2 - 1;
      const mouseY = -(touch.clientY / window.innerHeight) * 2 + 1;
      mouse.set(mouseX, mouseY);
      raycaster.update();
      const intersects = getIntersects(mouse.x, mouse.y);
      if (intersects.length > 0) {
        const object = intersects[0].object;
        if (object.text) {
          dragging = true;
          dragObject = object;
          lastMousePosition.x = touch.clientX;
          lastMousePosition.y = touch.clientY;
        }
      }
    }

    function onTouchMove(event) {
      if (dragging && dragObject) {
        const touch = event.touches[0];
        const deltaX = touch.clientX - lastMousePosition.x;
        const deltaY = touch.clientY - lastMousePosition.y;
        dragObject.position.x += deltaX * 0.01;
        dragObject.position.y -= deltaY * 0.01;
        lastMousePosition.x = touch.clientX;
        lastMousePosition.y = touch.clientY;
      }
    }

    function onTouchEnd() {
      dragging = false;
      dragObject = null;
    }

    function getIntersects(x, y) {
      raycaster.update();
      raycaster.setFromCamera(mouse, camera);
      return raycaster.intersectObject(model.children, true);
    }

    function addText() {
      const text = document.getElementById('inputText').value;
      const color = document.getElementById('colorPicker').value;
      const size = parseFloat(document.getElementById('sizeSlider').value);
      
      if (!text) return;

      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      context.font = `${size}px Vazirmatn, sans-serif`;
      context.fillStyle = color;
      context.fillText(text, 0, size);
      const texture = new THREE.CanvasTexture(canvas);
      
      const geometry = new THREE.PlaneGeometry(1, 0.5);
      const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(0, 0, 0);
      mesh.text = true; // Mark the object as text
      model.add(mesh);
      texts.push(mesh);
    }

    function animate() {
      requestAnimationFrame(animate);
      if (model) {
        model.rotation.y += 0.01; // Rotate the model continuously
      }
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
